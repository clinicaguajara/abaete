# üì¶ IMPORTA√á√ïES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

import logging
import streamlit as st


from datetime                   import date, timedelta
from frameworks.sm              import StateMachine
from services.user_profile      import save_user_profile, load_user_profile
from utils.variables.constants            import SALARIO_MINIMO, TCLE


# üë®‚Äçüíª LOGGER ESPEC√çFICO PARA O M√ìDULO ATUAL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

# Cria ou recupera uma inst√¢ncia do objeto Logger com o nome do m√≥dulo atual.
logger = logging.getLogger(__name__)


# ‚öôÔ∏è FUN√á√ÉO PARA DECIDIR SE O QUESTION√ÅRIO SER√Å RENDERIZADO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

def render_onboarding_if_needed(auth_machine: StateMachine, user_profile: dict) -> None:
    """
    Verifica se o perfil precisa de onboarding e, se necess√°rio, exibe o formul√°rio.
    """
    perfil_incompleto = (
        not user_profile or
        any(
            user_profile.get(k) is None
            for k in ["gender", "birthdate", "race", "income_range", "disabilities", "consent"]
        )
    )

    if perfil_incompleto:
        render_onboarding_questionnaire(auth_machine, user_profile)
        st.stop()


# üì∫ FUN√á√ÉO PARA RENDERIZAR ONBOARDING DO USU√ÅRIO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

def render_onboarding_questionnaire(auth_machine: StateMachine, user_profile: dict) -> tuple[None, str | None]:
    """
    <docstrings> Exibe o question√°rio de onboarding com campos din√¢micos, usando os dados da m√°quina de autentica√ß√£o.

    Args:
        auth_machine (StateMachine): M√°quina de estado com dados do usu√°rio autenticado.
        user_profile (dict): Dados do perfil carregados previamente.

    Calls:
        save_user_profile(): Persiste os dados no backend | definida em services/user_profile.py.
        load_user_profile(): Recarrega perfil ap√≥s salvar | definida em services/user_profile.py
        auth_machine.get_variable(): Recupera vari√°veis do usu√°rio | instanciado por StateMachine.
        st.form(): Cria formul√°rio com valida√ß√£o e envio | definida em streamlit.
        st.rerun(): For√ßa rerun ap√≥s transi√ß√£o de estado | definida em streamlit.runtime.

    Returns:
        Tuple[None, str | None]:
            - None: Se execu√ß√£o ocorrer normalmente.
            - str | None: Mensagem de erro em caso de falha.
    """
    
    CAMPOS_OBRIGATORIOS = ["display_name", "birthdate", "gender", "race", "income_range", "disabilities", "consent"]

    # Filtra campos ainda n√£o preenchidos (apenas None).
    campos_pendentes = [k for k in CAMPOS_OBRIGATORIOS if user_profile.get(k) is None]

    # üîí Se n√£o h√° campos pendentes, n√£o h√° formul√°rio a renderizar.
    if not campos_pendentes:
        return
    
    st.markdown("<h4>Antes de continuar, gostar√≠amos de saber mais sobre voc√™...</h4>", unsafe_allow_html=True)

    respostas = {}

    with st.form("form_onboarding"):
                
        if user_profile.get("display_name") is None:
            nome = st.text_input("Nome completo", placeholder="Ex: Anna O.")
            respostas["display_name"] = nome

        if user_profile.get("gender") is None:
            genero = st.selectbox("G√™nero", ["Masculino", "Feminino", "N√£o-bin√°rio"])
            genero_map = {"Masculino": "M", "Feminino": "F", "N√£o-bin√°rio": "N"}
            respostas["gender"] = genero_map[genero]

        if user_profile.get("birthdate") is None:
            hoje = date.today()
            limite_min = hoje - timedelta(days=120 * 365)
            nascimento = st.date_input("Data de nascimento", min_value=limite_min, max_value=hoje)
            respostas["birthdate"] = str(nascimento)

        if user_profile.get("race") is None:
            raca = st.selectbox("Etnia", ["Branca", "Preta", "Parda", "Amarela", "Ind√≠gena"])
            respostas["race"] = raca

        if user_profile.get("income_range") is None:
            faixas = [
                f"At√© 1 sal√°rio m√≠nimo (at√© R$ {1 * SALARIO_MINIMO:,.2f})",
                f"Entre 1 e 2 sal√°rios m√≠nimos (at√© R$ {2 * SALARIO_MINIMO:,.2f})",
                f"Entre 2 e 3 sal√°rios m√≠nimos (at√© R$ {3 * SALARIO_MINIMO:,.2f})",
                f"Entre 3 e 5 sal√°rios m√≠nimos (at√© R$ {5 * SALARIO_MINIMO:,.2f})",
                f"Mais de 5 sal√°rios m√≠nimos (acima de R$ {5 * SALARIO_MINIMO:,.2f})"
            ]
            renda = st.selectbox("Renda mensal familiar", faixas)
            respostas["income_range"] = renda

        if user_profile.get("disabilities") is None:
            diagnostico = st.text_input(
                "Voc√™ possui algum diagn√≥stico, transtorno ou condi√ß√£o m√©dica?",
                placeholder="Ex: TDAH, Transtorno de Ansiedade, Nenhum, etc."
            )
            respostas["disabilities"] = diagnostico

        if user_profile.get("consent") is None:
            if TCLE:
                st.divider()
                st.markdown(TCLE, unsafe_allow_html=True)
            st.info("ü™∂ Termo de Consentimento")
            respostas["consent"] = st.checkbox(
                "**Autorizo a utiliza√ß√£o dos meus dados para fins de pesquisa.**"
            )

        enviar = st.form_submit_button("Submeter formul√°rio", use_container_width=True)

    if enviar:
        success = save_user_profile(auth_machine, respostas)
        if success:
            user_id = auth_machine.get_variable("user_id")
            load_user_profile(user_id, auth_machine)
            st.rerun()
        else:
            st.error("‚ùå N√£o foi poss√≠vel salvar o formul√°rio. Tente novamente.")

    return None, None
